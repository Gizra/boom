<?php
/**
 * @file
 * Code for the Shoov CI Build feature.
 */

include_once 'shoov_ci_build.features.inc';

/**
 * Return the CI builds that are waiting for processing.
 *
 * @param int $timestamp
 *   The timestamp of "now". If empty, the existing current time will be used.
 * @param int $range
 *   The number of maximum items to return. Defaults to 50.
 *
 * @return array
 *   Array of Message objects, or NULL if none found.
 */
function shoov_ci_build_get_ci_builds($timestamp = NULL, $range = 50) {
  $timestamp = $timestamp ?: time();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'message')
    ->entityCondition('bundle', 'ci_build')
    ->fieldCondition('field_ci_build_timestamp', 'value', $timestamp, '<=')
    ->fieldCondition('field_ci_build_status', 'value', 'queue')
    ->range(0, $range)
    ->propertyOrderBy('mid')
    ->execute();

  if (empty($result['message'])) {
    return;
  }

  return message_load_multiple(array_keys($result['message']));
}

function shoov_ci_build_get_stuck_ci_builds($timestamp = NULL, $range = 50) {
  $timestamp = $timestamp ?: time() - variable_get('shoov_ci_stuck_ci_builds_timespan', 60 * 60);

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'message')
    ->entityCondition('bundle', 'ci_build')
    ->fieldCondition('field_ci_build_timestamp', 'value', $timestamp, '<=')
    ->fieldCondition('field_ci_build_status', 'value', 'in_progress')
    ->range(0, $range)
    ->propertyOrderBy('mid')
    ->execute();

  if (empty($result['message'])) {
    return;
  }

  return message_load_multiple(array_keys($result['message']));
}

/**
 * Implements hook_node_presave().
 *
 * Add a random private key to the CI build.
 */
function shoov_ci_build_node_presave($node) {
  if ($node->type != 'ci_build') {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  if ($wrapper->field_private_key->value()) {
    // Private key is already populated.
    return;
  }

  $wrapper->field_private_key->set(drupal_random_key());
}

/**
 * Implements hook_node_insert().
 *
 * Create a CI build item when a new CI build node is created.
 */
function shoov_ci_build_node_insert($node) {
  shoov_ci_build_create_item($node);
}

/**
 * Implements hook_node_update().
 *
 * Create a CI build item when an existing CI build is enabled.
 */
function shoov_ci_build_node_update($node) {
  shoov_ci_build_create_item($node);
}

/**
 * Create a CI build item.
 *
 * @param $node
 *   The CI-build node object.
 * @param int $timestamp
 *   The timestamp of "now". If empty, the existing current time will be used.
 *
 * @return Message | NULL
 *   The message object if all conditions were met.
 */
function shoov_ci_build_create_item($node, $timestamp = NULL) {
  if ($node->type != 'ci_build') {
    return;
  }

  $ci_build = $node;

  // Skip disabled CI Build.
  $ci_build_wrp = entity_metadata_wrapper('node', $ci_build);
  if (!$ci_build_wrp->field_ci_build_enabled->value()) {
    return;
  }

  // Verify a "queue" or "in progress" build items doesn't already exist.
  $status = array(
    'queue',
    'in_progress',
  );

  $query = new EntityFieldQuery();
  $count = $query
    ->entityCondition('entity_type', 'message')
    ->entityCondition('bundle', 'ci_build')
    ->fieldCondition('field_ci_build', 'target_id', $ci_build->nid)
    ->fieldCondition('field_ci_build_status', 'value', $status, 'IN')
    ->count()
    ->execute();

  if ($count) {
    return;
  }

  $timestamp = $timestamp ?: time();

  $ci_build_item = message_create('ci_build', array('uid' => $ci_build->uid));
  $ci_build_item_wrp = entity_metadata_wrapper('message', $ci_build_item);
  $ci_build_item_wrp->field_ci_build->set($node);
  $ci_build_item_wrp->field_ci_build_status->set('queue');
  // Set to be invoked immediately.
  $ci_build_item_wrp->field_ci_build_timestamp->set($timestamp);

  $ci_build_item_wrp->save();

  // Subscribe the author to the node.
  $account = user_load($ci_build->uid);
  flag('flag', 'subscribe_ci_builds', $ci_build->nid, $account);

  return $ci_build_item;
}

/**
 * Implements hook_message_update().
 *
 * @param \Message $ci_build_item
 *   The message object.
 */
function shoov_ci_build_message_update(Message $ci_build_item) {
  $ci_build_item_wrp = entity_metadata_wrapper('message', $ci_build_item);
  $ci_build_item_status = $ci_build_item_wrp->field_ci_build_status->value();

  // Stop process if CI build item still in intermediate state.
  if (!in_array($ci_build_item_status, array('error', 'done'))) {
    // Item still in progress or re-queued after being stuck.
    return;
  }

  // Stop process for disabled CI Build.
  if (!$ci_build_item_wrp->field_ci_build->field_ci_build_enabled->value()) {
    return;
  }

  $ci_build = $ci_build_item_wrp->field_ci_build->value();
  $ci_build_wrp = entity_metadata_wrapper('node', $ci_build);

  // If CI build item finished with error then increase the fail count.
  if ($ci_build_item_status == 'error') {
    $failed_count = $ci_build_wrp->field_ci_build_failed_count->value();
    $ci_build_wrp->field_ci_build_failed_count->set($failed_count + 1);

    // Save error status for CI Build if the count of fails is exceeded.
    if ($ci_build_wrp->field_ci_build_failed_count->value() >= variable_get('shoov_ci_build_failed_count_threshold', 3)) {
      $ci_build_wrp->field_ci_build_incident_status->set('error');

      // Continue test CI build in regular mode.
      // @todo: Make configurable.
      $timestamp = strtotime('+3 minutes');
    }
    // Or execute new CI build item immediately to check again.
    else {
      $ci_build_wrp->field_ci_build_incident_status->set('unconfirmed_error');
      $timestamp = FALSE;
    }
  }
  elseif ($ci_build_item_status == 'done') {
    // Release the fail count for CI Build and update the status.
    $ci_build_wrp->field_ci_build_failed_count->set(0);
    $ci_build_wrp->field_ci_build_incident_status->set(NULL);

    // Continue test CI build after 3 minutes.
    // @todo: Make configurable.
    $timestamp = strtotime('+3 minutes');
  }
  else {
    return;
  }
  
  $ci_build_wrp->save();

  shoov_ci_build_create_item($ci_build, $timestamp);
  shoov_ci_build_set_status($ci_build_item);
}

/**
 * Return the status of CI build.
 * 
 * @param $ci_build
 *   The id or object of specific CI Build.
 * @return string
 *   Possible statuses: 'ok', 'error', 'unconfirmed_error'.
 */
function shoov_ci_build_get_status($ci_build) {
  $ci_build_wrp = entity_metadata_wrapper('node', $ci_build);
  
  $ci_build_status = $ci_build_wrp->field_ci_build_incident_status->value();
  if (!$ci_build_status) {
    return 'ok';
  }

  $failed_count = $ci_build_wrp->field_ci_build_failed_count->value();

  if ($failed_count >= variable_get('shoov_ci_build_failed_count_threshold', 3)) {
    return 'error';
  }
  else {
    return 'unconfirmed_error';
  }
}

/**
 * Set the status of the CI build on failure, and clear when it's fixed.
 *
 * @param \Message $ci_build_item
 *   The CI build item object.
 */
function shoov_ci_build_set_status(Message $ci_build_item) {
  $ci_build_item_wrp = entity_metadata_wrapper('message', $ci_build_item);
  $ci_build = $ci_build_item_wrp->field_ci_build->value();
  $ci_build_status = shoov_ci_build_get_status($ci_build);

  // Do not update CI build status if CI build item not in complete state.
  if (!in_array($ci_build_item->field_ci_build_status, array('done', 'error'))) {
    return;
  }
  
  $ci_incident = shoov_ci_incident_get_latest_error_incident($ci_build);
  
  $arguments = array(
    '@repo' => $ci_build->field_ci_build->og_repo->label(),
    '@branch' => $ci_build->field_ci_build->field_git_branch->value(),
  );

  // @todo: Move to a general module?
  $client_url = variable_get('shoov_client_url', 'http://localhost:9000');

  if (!$ci_incident && $ci_build_status == 'error') {
    // Create a new incident.
    $message_type = 'ci_incident_error';
    $ci_incident = shoov_ci_incident_create_error_incident($ci_build_item);
    $options = array('fragment' => '/ci-incidents/' . $ci_incident->nid);
    $arguments += array(
      '@url' => url($client_url, $options),
    );
  }
  elseif ($ci_incident && $ci_build_status == 'ok') {
    // Mark the existing incident as fixed.
    $incident_wrp = entity_metadata_wrapper('node', $ci_incident);
    $incident_wrp->field_fixed_build->set($ci_build_item);
    $incident_wrp->field_ci_build_error->set(NULL);
    $incident_wrp->save();

    $message_type = 'ci_incident_fixed';
    $options = array('fragment' => '/ci-incidents/' . $ci_incident->nid);
    $arguments += array(
      '@url' => url($client_url, $options),
    );
  }
  else {
    return;
  }

  // Send a message to all following members.
  $incident_msg = message_create($message_type, array('arguments' => $arguments));
  $incident_msg->uid = $ci_build_item->uid;
  $message_wrapper = entity_metadata_wrapper('message', $incident_msg);
  $message_wrapper->field_ci_incident->set($ci_incident);

  $subscribe_options = array(
    'notify message owner' => TRUE,
  );
  message_subscribe_send_message('node', $ci_build, $incident_msg, array(), $subscribe_options);
}
